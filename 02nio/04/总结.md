# JVM GC策略和堆内存管理的总结
## 研究方法
我这里使用了不同的GC策略启动参数，配合GCLogAnalysis.java，进行了生产环境的模拟。  
对串行 / 并行 / CMS / G1 这4种策略，分别进行了512m/1024m/2048m/4096m堆内存下的gc日志打印。  
然后对日志进行了分析，并上传到gceasy上得到一些直观的图表。  
最后启动了自定义的spring boot服务，对使用不同gc策略时的吞吐量进行了研究。

## GC日志得出的结论
### GC暂停时间
从平均GC暂停时间来看，串行 > CMS > 并行 > G1  (暂停时间短的在前边)。  
从日志来看，从串行到并行，从并行到G1的提升，不管是平均暂停时间还是最大暂停时间都是十分明显的。  
但是并行和CMS之间的性能差距并不大，甚至在大部分测试结果中CMS的暂停时间还要大于并行。在512m的情况下，虽然CMS平均暂停时间小于并行，但是最大暂停时间大于并行，而在jvm堆内存比较大的情况下，两者都大于并行。

### 吞吐量
从结果来看吞吐量受堆内存影响较大，在512m的情况下，  
G1 > CMS > 串行 > 并行  
但是在4098m的情况下
G1 > 并行 > 串行 > CMS 

### GC策略的其他问题
在堆内存比较小的情况下:
1. CMS发生了Concurrent Mode Failure和Promotion Failure，造成了较长的GC。  
这一方面是因为CMS的垃圾收集是和用户并行执行的，收集效率低。
另一方面也是由于CMS的扫描清除策略和扫描预清理策略无法很好地应对浮动垃圾，
导致内存中新生成的对象和内存碎片问题无法很好地得到解决。  
2. G1也发生了Allocation Failure，由于MixedGC无法完成回收导致退化为了FullGC, 造成了较长时间的GC停顿


